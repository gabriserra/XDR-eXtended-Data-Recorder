function [data]=Turn_Checker(accx,accy,giroz)
      if(size(accx,1) == 1)
        accx=accx';
      end
      if(size(accy,1) == 1)
        accx=accx';
      end
      if(size(giroz,1) == 1)
        accx=accx';
      end
      
      turning = 0;
      j=1;
      start =0;
       candidates=0;
      for i=1:1:size(giroz,1)
      
        if(turning == 0 && abs(giroz(i,1)) > 4)
            start=i;
            if(giroz(i,1) > 0)
               directions(j,1) = 1;
            else
                
               directions(j,1) = -1;
            end
                candidates(j,1) = i;
                j =j+1;
                turning=1;
        end
         
         if(j>1 && candidates(j-1,1) == 1859)
             turning
             giroz(i,1)
             directions
         end
        if(turning == 1 && ( (giroz(i,1) < 0 && directions(j-1,1) == 1) || ((giroz(i,1) > 0 && directions(j-1,1) == -1) )))
            interval(j-1,1) = i-start;
            turning = 0;
        end
        
        
      end
 
      [candidates interval]
      for i=1:1:size(candidates,1)
        %qui è necessario considerare ogni intervallo in cui si curve e s:
        %       1) basarsi su accx 
        %       2)
      end
      
      
      %ogni volta che trovo un candidato devo fare questo per trovare dove
      %finisce ma devo anche cercare verso sx per trovare bene dove
      %inizia
         
      
%       candidates= find(abs(giroz) > 4);
%       directions= ones(size(candidates,1),1);
%       
%        for i=1:1:size(candidates,1)
%         
%         j=candidates(i,1)+1
%         if(directions(i,1) > 0)
%             
%             while (giroz(j) > 0)
%                 j = j+1;
%             end
%             interval(i,1) = j-candidates(i,1)-1;
%             j=candidates(i+j,1);
%         
%         else
%             while (giroz(j) < 0)
%                 j = j+1;
%             end
%             interval(i,1) = j-candidates(i,1)-1;
%             j=candidates(i+j,1);
%         
%         end
%         interval(i,1)
%     end
    % interval
      
    % turns
%       for i=1:1:size(turns,1)
%           [turns(i,1) giroz(turns(i,1))]
%         if (giroz(turns(i,1) < 0))
%             directions(i,1) = -1;
%         end
%       end
%   
%       turns(1,1);
%       i=1;
%       j=1;
%       next_index=turns(1,1);
% 
%      while (~isempty(next_index))
%           end_turn = find(giroz(next_index:size(giroz,1),1)< 0) -1;
%           end_turn =end_turn(1,1);
%           next = next_index+end_turn(1,1)   ;                                  %indice fine curva
%                
%           data(j,1) = next_index-1;                                             %starting point
%           data(j,2) = end_turn(1,1);                                          %interval
%           data(j,3) = mean(abs(accx(next_index:next,1)));       
%           data(j,4) = mean(abs(accy(next_index:next,1)));       
%           data(j,5) = var(abs(accy(next_index:next,1)));  
%           
%           next_index = find(turns > next);                                    %prossimo punto iniziale
%        
%           if(~isempty(next_index))
%             next_index = next_index(1,1);
%             next_index = turns(next_index,1);                                               %punto di partenza nuovo        
%           end       
%           j=j+1;
% 
%      end


end